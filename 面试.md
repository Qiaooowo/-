#   防抖和节流

1. **防抖**

> 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间

- 思路：

> 每次触发事件时都取消之前的延时调用方法

```
function debounce(fn) {
      let timeout = null; // 创建一个标记用来存放定时器的返回值
      return function () {
        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
        timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
          fn.apply(this, arguments);
        }, 500);
      };
    }
    function sayHi() {
      console.log('防抖成功');
    }

    var inp = document.getElementById('inp');
    inp.addEventListener('input', debounce(sayHi)); // 防抖
```

1. **节流**

> 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

- 思路：

> 每次触发事件时都判断当前是否有等待执行的延时函数

```
function throttle(fn) {
      let canRun = true; // 通过闭包保存一个标记
      return function () {
        if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
        canRun = false; // 立即设置为false
        setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
          fn.apply(this, arguments);
          // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
          canRun = true;
        }, 500);
      };
    }
    function sayHi(e) {
      console.log(e.target.innerWidth, e.target.innerHeight);
    }
    window.addEventListener('resize', throttle(sayHi));
```

# setTimeout、Promise、Async/Await 的区别

其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；
promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。 

#### 1. setTimeout

```
console.log('script start')	//1. 打印 script start
setTimeout(function(){
    console.log('settimeout')	// 4. 打印 settimeout
})	// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数
console.log('script end')	//3. 打印 script start
// 输出顺序：script start->script end->settimeout
```

#### 2. Promise

Promise本身是**同步的立即执行函数**， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。

```
console.log('script start')
let promise1 = new Promise(function (resolve) {
    console.log('promise1')
    resolve()
    console.log('promise1 end')
}).then(function () {
    console.log('promise2')
})
setTimeout(function(){
    console.log('settimeout')
})
console.log('script end')
// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout
```

当JS主线程执行到Promise对象时，

- promise1.then() 的回调就是一个 task
- promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue
- promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中
- setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况

#### 3. async/await

```
async function async1(){
   console.log('async1 start');
    await async2();
    console.log('async1 end')
}
async function async2(){
    console.log('async2')
}

console.log('script start');
async1();
console.log('script end')

// 输出顺序：script start->async1 start->async2->script end->async1 end
```

async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。

# js如何实现异步

> js引擎是单线程的，实现异步依赖的是浏览器的多线程机制。

1. 浏览器的多进程包含GUI（界面渲染）、js主线程、dom事件触发线程（click、onMouseOver）、定时器线程（setTimeout、setInterval）、HTTP请求线程等。由于js可以操作DOM从而引发回流、重绘等影响UI渲染，因此js线程和GUI线程是互斥的。
2. js主线程在执行过程中，异步代码会被放到相应的线程中，如：

> 1、click事件会被放到DOM binding模块里，当事件被触发，DOM binding负责将事件回调放到任务队列中等待执行；
> 2、定时器事件会被放到timer模块里，当delay时间到达，timer模块“触发”定时器的回调函数，即将回调函数放到任务队列中等待执行；
> 注：interval回调：浏览器实现机制决定，当delay时间到达，但任务队列中存在一个等待执行的interval回调时，此次的回调不会会被舍弃，不会加入任务队列等待执行。
> 3、网络请求会被放到network模块中，即请求由http线程发送而不是js主线程，当网络请求状态变更后，http线程将coder设置好的回调加入任务队列等待执行（即onreadystatechange函数的回调）；

**异步线程完成后的结果放入事件循环队列中**

（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件（回调函数callback）。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。

“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。

所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。



# 常见异步笔试题，请写出代码的运行结果 

# 从一道题浅说 JavaScript 的事件循环

**注：本篇文章运行环境为当前最新版本的谷歌浏览器（72.0.3626.109）**

最近看到这样一道有关事件循环的前端面试题：

```
//请写出输出内容
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
	console.log('async2');
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0)

async1();

new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');


/*
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
*/
```

https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7



# 算法手写题-数组扁平化

已知如下数组：

var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];

编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
————————————————

arr.toString().split(",").sort((a,b)=>{ return a-b}).map(Number) //结果并没有去重！！！

Array.from(new Set(arr.toString().split(",").sort((a,b)=>{ return a-b}).map(Number)))



```
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]
// 扁平化
let flatArr = arr.flat(4)
// 去重
let disArr = Array.from(new Set(flatArr))
// 排序
let result = disArr.sort(function(a, b) {
    return a-b
})
console.log(result)
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```

# 如何实现一个 new 

```
// 实现一个new
var Dog = function(name) {
  this.name = name
}
Dog.prototype.bark = function() {
  console.log('wangwang')
}
Dog.prototype.sayName = function() {
  console.log('my name is ' + this.name)
}
let sanmao = new Dog('三毛')
sanmao.sayName()
sanmao.bark()
// new 的作用
// 创建一个新对象obj
// 把obj的__proto__指向Dog.prototype 实现继承
// 执行构造函数，传递参数，改变this指向 Dog.call(obj, ...args)
// 最后把obj赋值给sanmao
var _new = function() {
  let constructor = Array.prototype.shift.call(arguments)
  let args = arguments
  const obj = new Object()
  obj.__proto__ = constructor.prototype
  constructor.call(obj, ...args)
  return obj
}
var simao = _new(Dog, 'simao')
simao.bark()
simao.sayName()
console.log(simao instanceof Dog) // true
```

# 谈谈你对 TCP 三次握手和四次挥手的理解

![image](https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png)

第一次握手 主机A 发送一个SYN=1的TCP包给服务器，随机产生一个数字seq=x作为确认号，服务器收到SYN=1包知道了主机A要建立连接

第二次握手 服务器收到请求后 发送一个SYN=1 ack等于A主机seq+1的确认包  ACK（确认号）=1 seq=y

第三次握手 主机A 收到服务器回复 发送一个SYN = 1 ACK=1 ack=y+1 seq=x+1

# 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() 

#### 1. Object.prototype.toString.call()

每一个继承 Object 的对象都有 `toString` 方法，如果 `toString` 方法没有重写的话，会返回 `[Object type]`，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 `toString` 方法时，会直接返回都是内容的字符串，所以我们需要使用call或者apply方法来改变toString方法的执行上下文。

```
const an = ['Hello','An'];
an.toString(); // "Hello,An"
Object.prototype.toString.call(an); // "[object Array]"
```

这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。

```
Object.prototype.toString.call('An') // "[object String]"
Object.prototype.toString.call(1) // "[object Number]"
Object.prototype.toString.call(Symbol(1)) // "[object Symbol]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(undefined) // "[object Undefined]"
Object.prototype.toString.call(function(){}) // "[object Function]"
Object.prototype.toString.call({name: 'An'}) // "[object Object]"
```

`Object.prototype.toString.call()` 常用于判断浏览器内置对象时。

更多实现可见 [谈谈 Object.prototype.toString](https://juejin.im/post/591647550ce4630069df1c4a)

#### 2. instanceof

`instanceof` 的内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

使用 `instanceof`判断一个对象是否为数组，`instanceof` 会判断这个对象的原型链上是否会找到对应的 `Array` 的原型，找到返回 `true`，否则返回 `false`。

```
[]  instanceof Array; // true
```

但 `instanceof` 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。

```
[]  instanceof Object; // true
```

#### 3. Array.isArray()

- 功能：用来判断对象是否为数组

- instanceof 与 isArray

  当检测Array实例时，`Array.isArray` 优于 `instanceof` ，因为 `Array.isArray` 可以检测出 `iframes`

  ```
  var iframe = document.createElement('iframe');
  document.body.appendChild(iframe);
  xArray = window.frames[window.frames.length-1].Array;
  var arr = new xArray(1,2,3); // [1,2,3]
  
  // Correctly checking for Array
  Array.isArray(arr);  // true
  Object.prototype.toString.call(arr); // true
  // Considered harmful, because doesn't work though iframes
  arr instanceof Array; // false
  ```

- `Array.isArray()` 与 `Object.prototype.toString.call()`

  `Array.isArray()`是ES5新增的方法，当不存在 `Array.isArray()` ，可以用 `Object.prototype.toString.call()` 实现。

  ```
  if (!Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };
  }
  ```

#### `typeof`:

1.返回值是一个字符串， 用来说明变量的数据类型。
2.typeof 一般只能返回如下几个结果： number, boolean, string, function, object, undefined。

# 介绍下重绘和回流（Repaint & Reflow），以及如何进行优化

#### 1. 浏览器渲染机制

- 浏览器采用流式布局模型（`Flow Based Layout`）
- 浏览器会把`HTML`解析成`DOM`，把`CSS`解析成`CSSOM`，`DOM`和`CSSOM`合并就产生了渲染树（`Render Tree`）。
- 有了`RenderTree`，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
- 由于浏览器使用流式布局，对`Render Tree`的计算通常只需要遍历一次就可以完成，**但`table`及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用`table`布局的原因之一**。

#### 2. 重绘

由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如`outline`, `visibility`, `color`、`background-color`等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。

#### 3. 回流

回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。

```
<body>
<div class="error">
    <h4>我的组件</h4>
    <p><strong>错误：</strong>错误的描述…</p>
    <h5>错误纠正</h5>
    <ol>
        <li>第一步</li>
        <li>第二步</li>
    </ol>
</div>
</body>
```

在上面的HTML片段中，对该段落(`<p>`标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（`div.error`和`body` – 视浏览器而定）。此外，`<h5>`和`<ol>`也会有简单的回流，因为其在DOM中在回流元素之后。**大部分的回流将导致页面的重新渲染。**

**回流必定会发生重绘，重绘不一定会引发回流。**

#### 4. 浏览器优化

现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你**获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值**。

主要包括以下属性或方法：

- `offsetTop`、`offsetLeft`、`offsetWidth`、`offsetHeight`
- `scrollTop`、`scrollLeft`、`scrollWidth`、`scrollHeight`
- `clientTop`、`clientLeft`、`clientWidth`、`clientHeight`
- `width`、`height`
- `getComputedStyle()`
- `getBoundingClientRect()`

所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。

#### 5. 减少重绘与回流

1. CSS

   - **使用 `transform` 替代 `top`**

   - **使用 `visibility` 替换 `display: none`** ，因为前者只会引起重绘，后者会引发回流（改变了布局

   - **避免使用`table`布局**，可能很小的一个小改动会造成整个 `table` 的重新布局。

   - **尽可能在`DOM`树的最末端改变`class`**，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。

   - **避免设置多层内联样式**，CSS 选择符**从右往左**匹配查找，避免节点层级过多。

     ```
     <div>
       <a> <span></span> </a>
     </div>
     <style>
       span {
         color: red;
       }
       div > a > span {
         color: red;
       }
     </style>
     ```

     对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 `span` 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 `span` 标签，然后找到 `span` 标签上的 `a` 标签，最后再去找到 `div` 标签，然后给符合这种条件的 `span` 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写**过于具体**的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证**层级扁平**。

   - **将动画效果应用到`position`属性为`absolute`或`fixed`的元素上**，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 `requestAnimationFrame`，详见[探讨 requestAnimationFrame](https://github.com/LuNaHaiJiao/blog/issues/30)。

   - **避免使用`CSS`表达式**，可能会引发回流。

   - **将频繁重绘或者回流的节点设置为图层**，图层能够阻止该节点的渲染行为影响别的节点，例如`will-change`、`video`、`iframe`等标签，浏览器会自动将该节点变为图层。

   - **CSS3 硬件加速（GPU加速）**，使用css3硬件加速，可以让`transform`、`opacity`、`filters`这些动画不会引起回流重绘 。但是对于动画的其它属性，比如`background-color`这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

2. JavaScript

   - **避免频繁操作样式**，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
   - **避免频繁操作`DOM`**，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
   - **避免频繁读取会引发回流/重绘的属性**，如果确实需要多次使用，就用一个变量缓存起来。
   - **对具有复杂动画的元素使用绝对定位**，使它脱离文档流，否则会引起父元素及后续元素频繁回流。
   - 

# 请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]。

```
const arr1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
const arr2 = ['A', 'B', 'C', 'D']
const ret = []
let tmp = arr2[0]
let j = 0
for (let i=0;i<arr1.length;i++) {
  if (tmp === arr1[i].charAt(0)){
    ret.push(arr1[i])
  }else {
    ret.push(tmp)
    ret.push(arr1[i])
    tmp=arr2[++j]
  }
   if(i===arr1.length-1){
      ret.push(tmp)
    }
}
console.log(ret)
```

```
let a1 =  ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
let a2 = ['A', 'B', 'C', 'D'].map((item) => {
  return item + 3
})

let a3 = [...a1, ...a2].sort().map((item) => {
  if(item.includes('3')){
    return item.split('')[0]
  }
  return item
})
```

# 改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。

```js
for (var i = 0; i< 10; i++){
	setTimeout(() => {
		console.log(i);
    }, 1000)
}
```

#### 解决办法汇总

- 方法一

  原理：

  - 利用 `setTimeout` 函数的第三个参数，会作为回调函数的第一个参数传入
  - 利用 `bind` 函数部分执行的特性

  代码 1：

  ```
  for (var i = 0; i < 10; i++) {
    setTimeout(i => {
      console.log(i);
    }, 1000, i)
  }
  ```

  代码 2：

  ```
  -
  ```
  
  代码 3：

  ```
for (var i = 0; i < 10; i++) {
    setTimeout(console.log.bind(Object.create(null), i), 1000)
  }
  ```
  
- 方法二

  原理：

  - 利用 `let` 变量的特性 — 在每一次 `for` 循环的过程中，`let` 声明的变量会在当前的块级作用域里面（`for` 循环的 body 体，也即两个花括号之间的内容区域）创建一个文法环境（Lexical Environment），该环境里面包括了当前 `for` 循环过程中的 `i`，[具体链接](https://javascript.info/closure#for-while)

  代码 1：

  ```
  for (let i = 0; i < 10; i++) {
    setTimeout(() => {
      console.log(i);
    }, 1000)
  }
  ```

  等价于

  ```
  for (let i = 0; i < 10; i++) {
    let _i = i;// const _i = i;
    setTimeout(() => {
      console.log(_i);
    }, 1000)
  }
  ```

- 方法三

  原理：

  - 利用函数自执行的方式，把当前 for 循环过程中的 i 传递进去，构建出块级作用域。

    IIFE 其实并不属于闭包的范畴

    。参考链接如下：

    - [difference-between-closures-and-iifes-in-javascript](https://stackoverflow.com/questions/41228824/difference-between-closures-and-iifes-in-javascript)
    - [IIFE 是闭包?](https://bit.ly/2NXNT56)

  - 利用其它方式构建出块级作用域

  代码 1：

  ```
  for (var i = 0; i < 10; i++) {
    (i => {
      setTimeout(() => {
        console.log(i);
      }, 1000)
    })(i)
  }
  ```

  代码 2：

  ```
  for (var i = 0; i < 10; i++) {
    try {
      throw new Error(i);
    } catch ({
      message: i
    }) {
      setTimeout(() => {
        console.log(i);
      }, 1000)
    }
  }
  ```

- 方法四

  原理：

  - 很多其它的方案只是把 `console.log(i)` 放到一个函数里面，因为 `setTimeout` 函数的第一个参数只接受函数以及字符串，如果是 `js` 语句的话，`js` 引擎应该会自动在该语句外面包裹一层函数

  代码 1：

  ```
  for (var i = 0; i < 10; i++) {
    setTimeout(console.log(i), 1000)
  }
  ```

  代码 2：

  ```
  for (var i = 0; i < 10; i++) {
    setTimeout((() => {
      console.log(i);
    })(), 1000)
  }
  ```

  代码 3：

  ```
  for (var i = 0; i < 10; i++) {
    setTimeout((i => {
      console.log(i);
    })(i), 1000)
  }
  ```

  代码 4：

  ```
  for (var i = 0; i < 10; i++) {
    setTimeout((i => {
      console.log(i);
    }).call(Object.create(null), i), 1000)
  }
  ```

  代码 5：

  ```
  for (var i = 0; i < 10; i++) {
    setTimeout((i => {
      console.log(i);
    }).apply(Object.create(null), [i]), 1000)
  }
  ```

  代码 6：

  ```
  for (var i = 0; i < 10; i++) {
    setTimeout((i => {
      console.log(i);
    }).apply(Object.create(null), { length: 1, '0': i }), 1000)
  }
  ```

- 方法五

  原理：

  - 利用 eval 或者 new Function 执行字符串，然后执行过程同方法四

  代码 1：

  ```
  for (var i = 0; i < 10; i++) {
    setTimeout(eval('console.log(i)'), 1000)
  }
  ```

  代码 2：

  ```
  for (var i = 0; i < 10; i++) {
    setTimeout(new Function('i', 'console.log(i)')(i), 1000)
  }
  ```

  代码 3：

  ```
  for (var i = 0; i < 10; i++) {
    setTimeout(new Function('console.log(i)')(), 1000)
  }
  ```

# 浏览器从输入URL到渲染完页面的整个过程

**从输入URL到渲染出整个页面的过程包括三个部分：**

1、DNS解析URL的过程

2、浏览器发送请求与服务器交互的过程

3、浏览器对接收到的html页面渲染的过程

**一、DNS解析URL的过程**

   DNS解析的过程就是寻找哪个服务器上有请求的资源。因为ip地址不容易记忆，一般会使用URL域名（如www.baidu.com）作为网址。DNS解析就是将域名翻译成IP地址的过程。

具体过程：

​    1）浏览器缓存：浏览器会按照一定的频率 缓存DNS记录

 　2）操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就会取操作系统中找

　　 3）路由缓存：路由器也有DNS缓存

　　 4）ISP的DNS服务器：ISP有专门的DNS服务器应对DNS查询请求

　　 5）根服务器：ISP的DNS服务器找不到之后，就要向根服务器发出请求，进行递归查询

**二、浏览器与服务器交互过程**

　　1）首先浏览器利用tcp协议通过三次握手与服务器建立连接

　　http请求包括header和body。header中包括请求的方式（get和post）、请求的协议 （http、https、ftp）、请求的地址ip、缓存cookie。body中有请求的内容。

　　2）浏览器根据解析到的IP地址和端口号发起http的get请求.

　　3）服务器接收到http请求之后，开始搜索html页面，并使用http返回响应报文

　　4）若状态码为200显示响应成功，浏览器接收到返回的html页面之后，开始进行页面的渲染

**三、浏览器页面渲染过程**

　　1）浏览器根据深度遍历的方式把html节点遍历成dom 树

　　2）将css解析成CSS DOM树

　　3）将dom树和CSS DOM树构造成render树

　　4）JS根据得到的render树 计算所有节点在屏幕中的位置，进行布局（回流）

　　5）遍历render树并调用硬件API绘制所有节点（重绘）

# （京东）下面代码中 a 在什么情况下会打印 1？

```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
```

这题考察的应该是类型的隐式转换,考引用类型在比较运算符时候,隐式转换会调用本类型toString或valueOf方法.
解答：

> ```
> var a = {num:0};
> a.valueOf = function(){
>   return ++a.num
> }
> if(a == 1 && a == 2 && a == 3){
>   console.log(1);
> }
> ```

```
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}

if( a == 1 && a == 2 && a == 3 ) {
  console.log(1);
}
```

# js中的变量与函数提升

```
function foo() {
  var a = 1;
  console.log(a);
  console.log(b);
  var b = 2;
}
foo();
```

上面的代码在js的眼中是这样解析的：

```js
Copyfunction foo() {
  var a;
  var b;
  a = 1;
  console.log(a); // 1
  console.log(b); // undefined
  b = 2;
}
foo();
```

### 变量提升和函数提升的顺序 变量声明>函数声明

在作用域中，不管是变量还是函数，都会提升到作用域最开始的位置，不同的是，函数的提升后的位置是在变量提升后的位置之后的。

举个栗子：

下面的代码输出什么？

```js
Copyfunction foo() {
  console.log(a);
  var a = 1;
  console.log(a);
  function a() {}
  console.log(a);
}
foo();
```

上面的代码在js眼中是这样解析的：

```js
Copyfunction foo() {
  var a;
  function a() {}
  console.log(a); // a()
  a = 1;
  console.log(a); // 1
  console.log(a); // 1
}
foo();
```

所以从上面的栗子可以看到，变量的提升是在函数提升之前的，但是变量赋值的部分是在js原型到变量定义的位置才给变量赋值的，而函数提升是相当于直接剪切到最前面的。

**注意：只有声明的变量和函数才会进行提升，隐式全局变量不会提升。**

下面的栗子中，b不会进行变量提升。

```js
Copyfunction foo() {
  console.log(a);
  console.log(b); // 报错
  b = 'aaa';
  var a = 'bbb';
  console.log(a);
  console.log(b);
}
foo();
```

# 某公司 1 到 12 月份的销售额存在一个对象里面

如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。



```
let obj = {1:222, 2:123, 5:888};
obj.length = 13;
let _obj = Array.from(obj).slice(1);
let newObj =  _obj.map((item) => {if(item === undefined) {return null;} else {return item;}});
console.log(newObj);
```

```
var obj = {
1: 222,
2: 123,
5: 888,
}
var arr = new Array(12).fill(null);
var finalArr = arr.map((v,i) => {
if (obj[i + 1]) {
return obj[i + 1];
} else {
return null;
}
});
console.log('--log--:', finalArr)
```

```
let data = {1:222, 2:123, 5:888};
let arr = Array.from({length:12}).map((it,i)=> data[i+1]||null);
console.log(arr)
```

# 冒泡排序及优化

```php
function maopao(arr){
  const array = [...arr]
  for(let i = array.length; i > 0; i--){
    for(let j =0; j < i - 1; j++) {
      if (array[j] > array[j + 1]) {
        let temp = array[j]
        array[j] = array[j + 1]
        array[j + 1] = temp
      }
    }
  }
  return array
}
```

优化

```php
function maopao1(arr){
  const array = [...arr]
  for(let i = array.length; i > 0; i--){
    let isOk = true
    for(let j =0; j < i - 1; j++) {
      if (array[j] > array[j + 1]) {
        let temp = array[j]
        array[j] = array[j + 1]
        array[j + 1] = temp
        isOk = false
      }
    }
    if (isOk) {
      break
    }
  }
  return array
}
```

加个标识，如果已经排好序了就直接跳出循环。

# 实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现

## 实现一个sleep函数

```
const sleep = (time) => {
  return new Promise(resolve => setTimeout(resolve, time))
}

sleep(1000).then(() => {
    // 这里写你的骚操作
})
```

```
const sleep = (time) => {
  return new Promise(resolve => setTimeout(resolve, time))
}

async function sleepAsync() {
  console.log('fuck the code')
  await sleep(1000)
  console.log('fuck the code again')
}

sleepAsync()
```



# 给定两个数组，写一个方法来计算它们的交集。

> 例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。

哈希表，时间复杂度O(m + n) m为nums1长度，n为nums2长度

```
var nums2 = [1, 2, 2, 1], nums1 = [2, 3, 4];
const intersect = (nums1, nums2) => {
  const map = {}
  const res = []
  for (let n of nums1) {
    if (map[n]) {
      map[n]++
    } else {
      map[n] = 1
    }
  }
  for (let n of nums2) {
    if (map[n] > 0) {
      res.push(n)
      map[n]--
    }
  }
  return res
}
console.log(intersect(nums1, nums2))
```

#### for in 和for of的区别

*记住，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。*

# 如何设计实现无缝轮播

设计第一张图和最后一张图的克隆

# 模拟实现一个 Promise.finally

```
Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  => P.resolve(callback()).then(() => value),
    reason => P.resolve(callback()).then(() => { throw reason })
  );
};
```

# 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。

```
let arr = [...new Set([2, 10, 3, 4, 5, 11, 10, 11, 10, 20].sort((a,b)=> a-b))]
let result = []
arr.forEach((item) => {
    let index = parseInt(item / 10)
    if (!result[index]) result[index] = [];
    result[index].push(item)
})
console.log(result)
```

#  如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC' 变成 'aBc' 

```
function processString (s) {
    var arr = s.split('');
    var new_arr = arr.map((item) => {
        return item === item.toUpperCase() ? item.toLowerCase() : item.toUpperCase();
    });
    return new_arr.join('');
}
console.log(processString('AbC'));
```



# 数组五种查询条件方法(find、findindex、indexOf、lastindexOf 、includes)

#### 方法一、find() 方法返回数组中满足提供的测试函数的第一个元素的值。

```
语法： arr.find(callback[, thisArg])

例一、find()方法 查找数组中第一个大于等于15的元素

var num = [10,3,5,15,100,1].find(function(elem, index){    
    return elem>=15;
});
console.log(num)     // 15
1
2
3
4
5
6
```



#### 方法二、findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。

```
语法： arr.findIndex(callback[, thisArg])

例二、findIndex() 查找数组中第一个大于等于15的元素的位置（索引）

var num = [10,3,5,15,100,1].findIndex(function(elem, index){    // 15
    return elem>=15;
});
console.log(num)     // 3
1
2
3
4
5
6
```



#### 方法三、indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回-1。

```
语法： arr.indexOf(searchElement)
arr.indexOf(searchElement[, fromIndex = 0])

例三、indexOf () 查找5所在的位置，默认索引位置从零开始

[0,1,2,3,4,5,6].indexOf(5);    // 5    从索引0的位置往后查找
[0,1,2,3,4,5,6].indexOf(5,5);  // 5
[0,1,2,3,4,5,6].indexOf(5,10); // -1   从索引10的位置往后查找

1
2
3
4
5
6
```



#### 方法四、lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。

语法： arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])

```
例四、lastIndexOf() 查找5所在的位置，默认索引位置当前数组长度减一

[0,1,2,3,4,5,6].lastIndexOf(5);       // 5   从索引位置数组长度减一向前查找
[0,1,2,3,4,5,6].lastIndexOf(5, 6);    // 5
[0,1,2,3,4,5,6].lastIndexOf(5, 10);   // 5
[0,1,2,3,4,5,6].lastIndexOf(5, 1);    // -1   从索引1的位置向前查找
1
2
3
4
5
6
```



#### 方法五、includes() 方法用来判断当前数组是否包含某指定的值，如果是，则返回 true，否则返回 false。

语法： arr.includes(searchElement)
arr.includes(searchElement, fromIndex)

```
例五、includes

[0,1,2,3,4,5,6].includes(5);                 // true     从索引0位置往后查找是否存在5元素，是
[0,1,2,3,4,5,6].includes(10);                // false
[0,1,2,3,4,5,6].includes(5,10);              // false    从索引10位置往后查找是否存在10元素，否
```

# 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。

```
var find = function(S,T){

  if(T.length > S.length) return -1;
    
  let index = S.indexOf(T);
  let count = [];

  while(index != -1){
    count.push(index);
    index = S.indexOf(T,index + T.length);
   }

    return count;
 }
```

indexOf 可以直接返回字符串所在的位置，但同时是否需要考虑，如果T在S中重复出现的

# 介绍下BFC,IFC,GFC和FFC

### **BFC**

   BFC(Block Formatting Contexts)直译为"块级格式化上下文"。Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。如何产生BFC？

float的值不为none。

overflow的值不为visible。

position的值不为relative和static。

display的值为table-cell, table-caption, inline-block中的任何一个。

***那BFC一般有什么用呢？\***

   比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。

### **IFC**

​    IFC(Inline Formatting Contexts)直译为"内联格式化上下文"，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)

IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。

***那么IFC一般有什么用呢？\***

​    水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。

​    垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。

### **GFC**

​    GFC(GridLayout Formatting Contexts)直译为"网格布局格式化上下文"，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。

***那么GFC有什么用呢，和table又有什么区别呢？***

​    首先同样是一个[二维](https://link.jianshu.com/?t=http://cpro.baidu.com/cpro/ui/uijs.php?adclass=0&app_id=0&c=news&cf=1001&ch=0&di=128&fv=0&is_app=0&jk=454552f46ec357d0&k=%B6%FE%CE%AC&k0=%B6%FE%CE%AC&kdi0=0&luki=7&mcpm=0&n=10&p=baidu&q=65035100_cpr&rb=0&rs=1&seller_id=1&sid=d057c36ef4524545&ssp2=1&stid=9&t=tpclicked3_hc&td=1836545&tu=u1836545&u=http%3A%2F%2Fwww.bubuko.com%2Finfodetail-1119912.html&urlid=0)的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。

### **FFC**

​    FFC(Flex Formatting Contexts)直译为"自适应格式化上下文"，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。

​    Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。

​    伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。

#  数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少

- 数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)
- JavaScript 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 key）来使用。所以无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。

# 输出以下代码运行结果-对象键名

```
// example 1
var a={}, b='123', c=123;
a[b]='b';
a[c]='c';
console.log(a[b]);

------

// example 2
var a={}, b=Symbol('123'), c=Symbol('123');
a[b]='b';
a[c]='c';
console.log(a[b]);

------

// example 3
var a={}, b={key:'123'}, c={key:'456'};
a[b]='b';
a[c]='c';
console.log(a[b]);
```

这题考察的是对象的键名的转换。

- 对象的键名只能是字符串和 Symbol 类型。
- 其他类型的键名会被转换成字符串类型。
- 对象转字符串默认会调用 toString 方法。

```
// example 1
var a={}, b='123', c=123;
a[b]='b';

// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉。
a[c]='c';  

// 输出 c
console.log(a[b]);
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');  

// b 是 Symbol 类型，不需要转换。
a[b]='b';

// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。
a[c]='c';

// 输出 b
console.log(a[b]);
// example 3
var a={}, b={key:'123'}, c={key:'456'};  

// b 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。
a[b]='b';

// c 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。
a[c]='c';  

// 输出 c
console.log(a[b]);
```

# 算法题「旋转数组」

> 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
>
> ```
> function rotate(arr, k) {
>   const len = arr.length
>   const step = k % len
>   return arr.slice(-step).concat(arr.slice(0, len - step))
> }
> // rotate([1, 2, 3, 4, 5, 6], 7) => [6, 1, 2, 3, 4, 5]
> ```



```
var rotate = function(nums, k) {
    for(var i = 0;i<k;i++){
        nums.unshift(nums.pop())
    }
    return nums;
}
```

# Vue 的父组件和子组件生命周期钩子执行顺序是什么 

1. 加载渲染过程
   `父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted`
2. 子组件更新过程
   `父beforeUpdate->子beforeUpdate->子updated->父updated`
3. 父组件更新过程
   `父beforeUpdate->父updated`
4. 销毁过程
   `父beforeDestroy->子beforeDestroy->子destroyed->父destroyed`

# 算法：打印出 1 - 10000 之间的所有对称数 例如 121、1331 等 

```
[...Array(10000).keys()].filter((x) => { 
  return x.toString().length > 1 && x === Number(x.toString().split('').reverse().join('')) 
})
```

```
var result = [];
for (let i = 1; i <= 10000; i++) {
	let origin = '' + i;
	let reverse = origin.split('').reverse().join('');
	if(origin === reverse &&origin.length > 1) {
		result.push(i);
	}
}
```

# 周一算法题之「移动零」

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
12
```

说明:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

```
var arr = [0,1,0,3,12];
for (let i in arr){
if(arr[i] == 0){
arr.splice(i,1);
arr.push(0);
}
}
console.log(arr)
```

```
const moveZore = (arr) => {
            let n = 0
            arr.forEach((item, index) => {
                if (item === 0){
                    arr.splice(index, 1)
                    n++;
                }
            })
            arr.push(...(new Array(n)).fill(0))
            return arr;
        }
```

# Router-link 和 a

`<router-link>` 比起写死的 `<a href="...">` 会好一些，理由如下：

- 无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动。
- 在 HTML5 history 模式下，`router-link` 会守卫点击事件，让浏览器不再重新加载页面。
- 当你在 HTML5 history 模式下使用 `base` 选项之后，所有的 `to` 属性都不需要写 (基路径) 了。

# var、let 和 const 区别的实现原理是什么

#### 先说说这三者的区别吧：

- var 和 let 用以声明变量，const 用于声明只读的常量；

- var 声明的变量，不存在块级作用域，在全局范围内都有效，let 和 const 声明的，只在它所在的代码块内有效；

- let 和 const 不存在像 var 那样的 [“变量提升”](https://www.jianshu.com/p/d4b88723cd12) 现象，所以 var 定义变量可以先使用，后声明，而 let 和 const 只可先声明，后使用；

- let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它所声明的变量就绑定了这个区域，不再受外部的影响。

- let 不允许在相同作用域内，重复声明同一个变量；

- const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明；

  > 如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。

###### 一.声明过程

var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来
function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高
let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行
const、class都是同let一样的道理

###### 二.内存分配

var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针

let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错

const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性

###### 三.变量提升

let const 和var三者其实会存在变量提升

- let只是**创建**过程提升，**初始化**过程并没有提升，所以会产生暂时性死区。
- var的**创建**和**初始化**过程都提升了，所以在赋值前访问会得到undefined
- function 的**创建、初始化、赋值**都被提升了

# 京东、快手）周一算法题之「两数之和」

给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。

你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

示例：

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

哈希表

```
function anwser (arr, target) {
  let map = {}
  for (let i = 0; i < arr.length; i++) {
    map[arr[i]] = i
  }
  for (let i = 0; i < arr.length; i++) {
    var d = target - arr[i]
    if (map[d]) {
      return [i, map[d]]
    }
  }
  return new Error('404 not found')
}
```

我的方法

```
var nums = [2, 7, 11, 15,1,6,5]
var target = 9;
var result = []
var newarr = nums.filter((item) => item < target)
for(let n of newarr){
if(newarr.includes(target - n)){
result.push(n)
result.push(target -n )
}
}
console.log(result)
```

# 实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度

```js
// 原始 list 如下
let list =[
    {id:1,name:'部门A',parentId:0},
    {id:2,name:'部门B',parentId:0},
    {id:3,name:'部门C',parentId:1},
    {id:4,name:'部门D',parentId:1},
    {id:5,name:'部门E',parentId:2},
    {id:6,name:'部门F',parentId:3},
    {id:7,name:'部门G',parentId:2},
    {id:8,name:'部门H',parentId:4}
];
const result = convert(list, ...);

// 转换后的结果如下
let result = [
    {
      id: 1,
      name: '部门A',
      parentId: 0,
      children: [
        {
          id: 3,
          name: '部门C',
          parentId: 1,
          children: [
            {
              id: 6,
              name: '部门F',
              parentId: 3
            }, {
              id: 16,
              name: '部门L',
              parentId: 3
            }
          ]
        },
        {
          id: 4,
          name: '部门D',
          parentId: 1,
          children: [
            {
              id: 8,
              name: '部门H',
              parentId: 4
            }
          ]
        }
      ]
    },
  ···
];
```

```js
function convert(list) {
	const res = []
	const map = list.reduce((res, v) => (res[v.id] = v, res), {})//以id为键存入res res初始为{}空对象
	for (const item of list) {
		if (item.parentId === 0) {
			res.push(item)
			continue
		}
		if (item.parentId in map) {
			const parent = map[item.parentId]
			parent.children = parent.children || []
			parent.children.push(item)
		}
	}
	return res
}
```

基于DFS来写

```javascript
function convert(source, parentId = 0){
    let trees = [];
    for (let item of source) {
      if(item.parentId === parentId) {
        let children = convert(source, item['id']);
        if(children.length) {
          item.children = children
        }
        trees.push(item);
      }
    }
    return trees;
  }

let list =[
    {id:1,name:'部门A',parentId:0},
    {id:2,name:'部门B',parentId:0},
    {id:3,name:'部门C',parentId:1},
    {id:4,name:'部门D',parentId:1},
    {id:5,name:'部门E',parentId:2},
    {id:6,name:'部门F',parentId:3},
    {id:7,name:'部门G',parentId:2},
    {id:8,name:'部门H',parentId:4}
];

const result = convert(list);
```

# （京东）请写出如下代码的打印结果

```
function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
Foo.prototype.a = function() {
    console.log(3)
}
Foo.a = function() {
    console.log(4)
}
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```

```
function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行

Foo.prototype.a = function() {
    console.log(3)
}
// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3

Foo.a = function() {
    console.log(4)
}
// 现在在 Foo 上挂载了直接方法 a ，输出值为 4

Foo.a();
// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以
// # 输出 4

let obj = new Foo();
/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：
1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。
2. 在新对象上挂载直接方法 a ，输出值为 2。
*/

obj.a();
// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，
// # 输出 2

Foo.a();
// 构建方法里已经替换了全局 Foo 上的 a 方法，所以
// # 输出 1
```

# 框架-vue性能优化

https://mp.weixin.qq.com/s/rwRYyh2KMHuLT0h616aEEw

### 1.代码层面的优化

#### 1.1、v-if 和 v-show 区分使用场景

**v-if** 是 **真正** 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

**v-show** 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。

所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。



#### 1.2、computed 和 watch 区分使用场景

**computed：** 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；

**watch：** 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

**运用场景**：

- 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；

- 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

  

#### 1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

**（1）v-for 遍历必须为 item 添加 key**

在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。

**（2）v-for 遍历避免同时使用 v-if**

v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。

**推荐：**

```
<ul>
  <li
    v-for="user in activeUsers"
    :key="user.id">
    {{ user.name }}
  </li>
</ul>
computed: {
  activeUsers: function () {
    return this.users.filter(function (user) {
 return user.isActive
    })
  }
}
```

**不推荐：**

```
<ul>
  <li
    v-for="user in users"
    v-if="user.isActive"
    :key="user.id">
    {{ user.name }}
  </li>
</ul>
```



#### 1.4、长列表性能优化

Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

```
export default {
  data: () => ({
    users: {}
  }),
  async created() {
    const users = await axios.get("/api/users");
    this.users = Object.freeze(users);
  }
};
```



#### 1.5、事件的销毁

Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：

```
created() {
  addEventListener('click', this.click, false)
},
beforeDestroy() {
  removeEventListener('click', this.click, false)
}
```



### 2.Webpack 层面的优化

#### 2.1、Webpack 对图片进行压缩

#### 2.2、减少 ES6 转为 ES5 的冗余代码

...



### 3.基础的 Web 技术优化

#### 3.1、开启 gzip 压缩

#### 3.2、浏览器缓存

#### 3.3、CDN 的使用



# prototype和	_proto_ 原型链

https://www.jianshu.com/p/7d58f8f45557

实例的proto指向prototype prototype中的constructor指针指回构造方法



### 简述原型链是什么，有什么用处？若想访问一个对象的原型，应该使用什么方法？

https://www.jianshu.com/p/c5d5d0b55148



# 如何减少页面加载时间

1.defer	

2.压缩css js代码

3.头部放css尾部放js

4.尽量减少DOM元素

5.使用	CDN



# 跨域方法

### 什么是跨域

当一个请求url的**协议、域名、端口**三者之间任意一个与当前页面url不同即为跨域



1.使用JSONP跨域

<script>标签
2.CORS 服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求，前后端都需要设置。

3.反向代理

## CORS

对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。

只要同时满足以下两大条件，就属于简单请求。

> （1) 请求方法是以下三种方法之一：
>
> - HEAD
> - GET
> - POST
>
> （2）HTTP的头信息不超出以下几种字段：
>
> - Accept
> - Accept-Language
> - Content-Language
> - Last-Event-ID
> - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。

凡是不同时满足上面两个条件，就属于非简单请求。

浏览器对这两种请求的处理，是不一样的。

### 3.1 基本流程

对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个`Origin`字段。

下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个`Origin`字段。

> ```http
> GET /cors HTTP/1.1
> Origin: http://api.bob.com
> Host: api.alice.com
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0...
> ```

上面的头信息中，`Origin`字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

> ```http
> Access-Control-Allow-Origin: http://api.bob.com
> Access-Control-Allow-Credentials: true
> Access-Control-Expose-Headers: FooBar
> Content-Type: text/html; charset=utf-8
> ```

上面的头信息之中，有三个与CORS请求相关的字段，都以`Access-Control-`开头。

**（1）Access-Control-Allow-Origin**

该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

**（2）Access-Control-Allow-Credentials**

该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为`true`，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。

**（3）Access-Control-Expose-Headers**

该字段可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。

#### 非简单请求



### 预检请求

非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。

非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器大量收到`DELETE`和`PUT`请求，这些传统的表单不可能跨域发出的请求。

下面是一段浏览器的 JavaScript 脚本。

```
var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
```

上面代码中，HTTP 请求的方法是`PUT`，并且发送一个自定义头信息`X-Custom-Header`。

浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。

```
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

“预检”请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。

除了`Origin`字段，“预检”请求的头信息包括两个特殊字段。

**（1）`Access-Control-Request-Method`**

该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是`PUT`。

**（2）`Access-Control-Request-Headers`**

该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是`X-Custom-Header`。



### 预检请求的回应

服务器收到“预检”请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

```
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

上面的 HTTP 回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

```
Access-Control-Allow-Origin: *
```

如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。

```
OPTIONS http://api.bob.com HTTP/1.1
Status: 200
Access-Control-Allow-Origin: https://notyourdomain.com
Access-Control-Allow-Method: POST
```

上面的服务器回应，`Access-Control-Allow-Origin`字段明确不包括发出请求的`http://api.bob.com`。

这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

```
XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
```

服务器回应的其他 CORS 相关字段如下。

```
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
```

**（1）`Access-Control-Allow-Methods`**

该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。

**（2）`Access-Control-Allow-Headers`**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。

**（3）`Access-Control-Allow-Credentials`**

该字段与简单请求时的含义相同。

**（4）`Access-Control-Max-Age`**

该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

# get和post

https://www.cnblogs.com/yinrw/p/10694735.html

- GET在浏览器回退时是无害的，而POST会再次提交请求。

   

- GET产生的URL地址可以被Bookmark，而POST不可以。

   

- GET请求会被浏览器主动cache，而POST不会，除非手动设置。

   

- GET请求只能进行url编码，而POST支持多种编码方式。

   

- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

   

- GET请求在URL中传送的参数是有长度限制的，而POST么有。

   

- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

   

- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

   

- GET参数通过URL传递，POST放在Request body中。

- GET和POST还有一个重大区别，简单的说：

  GET产生一个TCP数据包；POST产生两个TCP数据包。

   

  长的说：

  对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

  而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

   

  也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。

   

  因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？

  \1. GET与POST都有自己的语义，不能随便混用。

  \2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

  \3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

# 深度优先DFS和广度优先BFS

![image](https://user-images.githubusercontent.com/27856388/52606290-118a3180-2ead-11e9-86b7-d0feae6f8030.png)

```
/*深度优先遍历三种方式*/
let deepTraversal1 = (node, nodeList = []) => {
  if (node !== null) {
    nodeList.push(node)
    let children = node.children
    for (let i = 0; i < children.length; i++) {
      deepTraversal1(children[i], nodeList)
    }
  }
  return nodeList
}
let deepTraversal2 = (node) => {
    let nodes = []
    if (node !== null) {
      nodes.push(node)
      let children = node.children
      for (let i = 0; i < children.length; i++) {
        nodes = nodes.concat(deepTraversal2(children[i]))
      }
    }
    return nodes
  }
// 非递归
let deepTraversal3 = (node) => {
  let stack = []
  let nodes = []
  if (node) {
    // 推入当前处理的node
    stack.push(node)
    while (stack.length) {
      let item = stack.pop()
      let children = item.children
      nodes.push(item)
      // node = [] stack = [parent]
      // node = [parent] stack = [child3,child2,child1]
      // node = [parent, child1] stack = [child3,child2,child1-2,child1-1]
      // node = [parent, child1-1] stack = [child3,child2,child1-2]
      for (let i = children.length - 1; i >= 0; i--) {
        stack.push(children[i])
      }
    }
  }
  return nodes
}
```

广度优先遍历 BFS
从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。

```
let widthTraversal2 = (node) => {
  let nodes = []
  let stack = []
  if (node) {
    stack.push(node)
    while (stack.length) {
      let item = stack.shift()
      let children = item.children
      nodes.push(item)
        // 队列，先进先出
        // nodes = [] stack = [parent]
        // nodes = [parent] stack = [child1,child2,child3]
        // nodes = [parent, child1] stack = [child2,child3,child1-1,child1-2]
        // nodes = [parent,child1,child2]
      for (let i = 0; i < children.length; i++) {
        stack.push(children[i])
      }
    }
  }
  return nodes
}
```

# 深拷贝和浅拷贝

https://www.jianshu.com/p/35d69cf24f1f

```js
 function deepCopy(source,hash = new WeakMap()){
    if(Object.prototype.toString.call(source) !== '[object Object]'){return source;}
    if(hash.has(source)) return hash.get(source)
        let res = Array.isArray(source)? []:{};
        hash.set(source);
        for(let key in source){
            if(Object.prototype.hasOwnProperty.call(source,key)){
                res[key] = deepCopy(source[key]);
            }
        }
        return res;
  }
```



# Ajax请求过程

1.创建一个异步对象

2.第二步：设置 请求行 open(请求方式，请求url):

3.设置请求（请求头）**:setRequestHeader()**

4.设置请求体 send()

5.异步对象接收服务器响应

# Object.create和new的区别

https://www.jianshu.com/p/165cb07b9de0

下面这张图能清晰地看到每个函数和对象之间的关系，用圆形表示对象，方形表示函数。new做的操作就是先创建一个新的对象o1，这时o1._proto_指向Object.prototype。然后更改o1._proto_指向Base.prototype。最后用call强行转换作用环境，将构造函数的this指向o1，也就是o1拥有了构造函数Base定义的全部属性。

![img](https:////upload-images.jianshu.io/upload_images/12426656-3816c7d45fd4e9b6.png?imageMogr2/auto-orient/strip|imageView2/2/w/540/format/webp)



```dart
var o1 = new Object();
o1._proto_ = Base.prototype;
Base.call(o1);
```

再看看Object.create的实现方式



```jsx
Object.create =  function (Base) {
    var F = function () {};
    F.prototype = Base;
    return new F();
};
```

如下图所示，首先创建一个空函数F，函数的prototype指向Base函数。new一个函数的实例，即让该实例的_proto_指向函数F的prototype，也就是Base函数，最后将该实例返回。即通过Object.create创建的对象o2，实际上完成了o2._proto_ =  Base的操作。注意传入的参数Base2是一个对象。如果传入的是一个构造函数的话，该实例是无法继承的。



![img](https://upload-images.jianshu.io/upload_images/12426656-a29122c07252bc80.png?imageMogr2/auto-orient/strip|imageView2/2/w/508/format/webp)

# CSS继承

不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。
所有元素可继承：visibility和cursor。
内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。
终端块状元素可继承：text-indent和text-align。
列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。
表格元素可继承：border-collapse。 

# HTTP请求

**Get请求例子，使用Charles抓取的request：**

```
GET /562f25980001b1b106000338.jpg HTTP/1.1
Host    img.mukewang.com
User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
Accept    image/webp,image/*,*/*;q=0.8
Referer    http://www.imooc.com/
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=0.8
```

**第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.**

GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。

**第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息**

从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等

***\*Accept\**** 
请求报文可通过一个“Accept”报文头属性告诉服务端 客户端接受什么类型的响应。 

***\*cookie\****

客户端的Cookie就是通过这个报文头属性传给服务端的哦！

**Referer**
表示这个请求是从哪个URL过来的，假如你通过google搜索出一个商家的广告页面，你对这个广告页面感兴趣，鼠标一点发送一个请求报文到商家的网站，这个请求报文的Referer报文头属性值就是http://www.google.com。

**Cache-Control**

对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。

**第三部分：空行，请求头部后面的空行是必须的**

即使第四部分的请求数据为空，也必须有空行。

**第四部分：请求数据也叫主体，可以添加任意的其他数据。**

这个例子的请求数据为空。

**POST请求例子，使用Charles抓取的request：**

```
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

第一部分：请求行，第一行明了是post请求，以及http1.1版本。
第二部分：请求头部，第二行至第六行。
第三部分：空行，第七行的空行。
第四部分：请求数据，第八行。

# HTTP状态码

| 状态码 | 状态码英文名称                  | 中文描述                                                     |
| :----- | :------------------------------ | :----------------------------------------------------------- |
| 100    | Continue                        | 继续。[客户端](http://www.dreamdu.com/webbuild/client_vs_server/)应继续其请求 |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|        |                                 |                                                              |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|        |                                 |                                                              |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置“您所请求的资源无法找到”的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求   |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

# CSS垂直居中

1.已知宽高

使用Linheight

2.display设置为table

子元素display table-cell

vertiacal-align：middle

3.position absolute使用top left 50%然后margin-top margin-left改变偏移值

4.tranform 

position absolute使用top left 50%然后tranform：translate(-50%,-50%)

5.absolute然后top bottom设为0 使用margin auto

6.弹性布局

justify-content:center

align-items :cactus: :center

# flex布局

### 父节点属性

- flex-direction
- flex-wrap
- flex-flow
- justify-content
- align-items
- align-content

### 子节点属性

- `order`
- `flex-grow`
- `flex-shrink`
- `flex-basis`
- `flex`
- `align-self`

# !!!Promise对象

promise对象首先是一个object对象的实例，原型链上层为object对象

promise的原型函数中有三个自己的方法 分别是catch then 和finally

在构造函数constructor中有resolve reject race all方法-

创建promise对象时可以传入 resolve和reject方法

promise对象有三个状态 初始状态为pendding 我理解的 resolve和reject方法就是改变他的状态 如果运行成功则可以使用resolve将状态改变为fulfilled

Promise对象有两个特点：
①，对象的状态不受外界的影响，Promise有三种状态：Pending（进行中）、fulfilled（已成功）、rejected（失败），只用异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变这个操作。
②.一旦状态改变之后就不会再改变。任何时候都可以得到这个结果。状态变化只有两种可能：从pending到fulfilled和从pending到rejected。只要改变就已经定型了。

Promise的缺点：
① 一旦创建就无法取消，一旦新建就会立即执行
② 如果不设置回调函数，它的内部错误就不会反映到外部。
③ 当处于pending状态时，无法判断进展到哪一阶段（刚开始还是快完成）。

#### promise原型上的方法  then , catch,finally

不管是then方法还是catch方法返回的都是一个新的Promise实例，这意味着Promise可以链式调用then和catch，每一个方法的返回值作为下一个方法的参数：

如果其中一个then失败了，它后面第一个catch方法就会接受这个错误并执行，然后继续执行后面的方法，比如：



```jsx
var promise = new Promise(function (resolve, reject) {
    resolve()
})
promise.then(function (value) { // 抛出错误
    console.log(1 / x)
}).then(function () { // 此方法不会执行
    console.log('This "then" method will not happend!')
}).catch(function (error) { // 接受错误，并打印出错误
    console.log('Have an error: ',error)
}).then(function () { // 此方法会执行
    console.log('This "then" method  will happend!')
})
```



#### constructor上的方法 resolve,reject,all,race等

##### 1. Promise.all()

接收一个Promise对象的数组作为参数，当这个数组里的所有Promise对象全部变为resolve的时候，该方法才resolve。
 如果其中一个Promise对象为reject的话，则该方法为reject。
 比如：



```jsx
// `delay`毫秒后执行resolve
function timerPromisefy(delay) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve(delay);
        }, delay);
    });
}
// 当数组中所有Promise对象被resolve之后，该方法才返回
Promise.all([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then(function (value) {
    console.log(value);    
});

//输出： [ 1, 32, 64, 128 ]

```

手写promise.all

```js
function promiseAll(promises){
  // 返回一个promise实例
  return new Promise((resolve, reject) => {
    // 做一个判断参数是否是数组
    if(!Array.isArray(promises)){
      return reject(new TypeError('arguments must be Array'))
     }
 
   let count = 0,
       newValues = new Array(promise.length)  // 接收新的结果参数 建立一个伪数组
    for(let i = 0; i < promises.length; i++){ 
   // 运用promise特性 只会有一个状态
      Promise.resolve(promises[i])
      .then(res = > {
        count++
        newValues[i] = res // 把每次返回成功的数据添加到数组中
       if(count === promises.length){ // 数据接收完成
           return  resolve(newValues)  
        }
      }, rej = >  reject(rej))
    
     }
 
   }) 
}

```



##### 2. Promise.race()

使用方法和Promise.all一样，接收一个Promise对象数组为参数。
 只要其中一个Promise对象变为Resolved或者Rejected状态，该方法返回，进行后面的处理。
 看例子：



```jsx
// `delay`毫秒后执行resolve
function timerPromisefy(delay) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve(delay);
        }, delay);
    });
}
// 任何一个promise变为resolve或reject 的话程序就停止运行
Promise.race([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then(function (value) {
    console.log(value);    
});

// 输出： 1
```



加载图片的函数也使用Promise对象

```
function preloadImage(path){
    return new Promise(function(resolve,reject){
        var image = new Image();
        image.onload = resolve;
        image.onerror = reject;
        image.src = path;
    })
}
```

要实现的功能是在五秒之后如果图片加载不出来就提醒图片加载超时。

```
Promise.race([preloadImage("/images/1.png"),
            new Promise(function(resolve,reject){
                setTimeout(function() {
                    reject();
                },5000);
    })]).then(function(){
        alert("图片加载成功!")
    }).catch(function(){
    alert("图片加载失败!")
    })
```

### 手撕promise

```
class Promise {
    constructor(executor) {
        // 定义 resolve
        let resolve = res => {}
        // 定义 reject
        let reject = err => {}

        // 自动执行
        executor(resolve, reject);
    }
}

// 测试一下：
new Promise((resolve, reject) => {
    console.log('执行到啦~')
})
```

## Promise 三种状态实现

Ok，fine，接下来，我们来实现她的三种状态。

- [x] 4、三种状态
  - pending [待定] 初始状态
  - fulfilled [实现] 操作成功
  - rejected [被否决] 操作失败

promise 状态有如下特点:
1.promise 对象初始化状态为 pending

2.当调用resolve(成功)，会由pending => fulfilled

3.当调用reject(失败)，会由pending => rejected

> Promsie 状态 只能由 pending => fulfilled/rejected, 一旦修改就不能再变

```
class Promise {
    constructor(executor) {
        this.status = "pending"; // 默认状态
        this.value;  // resolve 成功时的值
        this.error;  // reject 失败时的值

        let resolve = res => {
            if(this.status === "pending") {
                this.value = res;
                this.status = "resolved";
            }
        }

        let reject = err => {
            if(this.status === "pending") {
                this.error = err;
                this.status = "rejected";
            }
        }

        executor(resolve, reject);
    }
}
```

Promise 对象方法 then 实现
[x] 5、Promise 对象方法 then
Promise 这个对象有 then 方法，还是先来分析，then 有什么？

```
then 接受两个回调
promise.then(onFulfilled, onRejected); // 这里假设 promise 继承于 Promise 类
```


我们继续在前面 Promise 类中书写 then 方法：

```
class Promise {
        constructor(executor) {
            this.status = "pending"; // 默认promise状态
            this.value;  // resolve成功时的值
            this.error;  // reject失败时的值
```




            let resolve = res => {
                if(this.status === "pending") {
                    this.value = res;
                    this.status = "resolved";
                }
            }
    
            let reject = err => {
                if(this.status === "pending") {
                    this.error = err;
                    this.status = "rejected";
                }
            }
    
            executor(resolve, reject)
        }
    
        // 声明 then
        then(onFullfilled, onRejected) {
            if(this.status === "resolved") {
                onFullfilled(this.value)
            }
            if(this.status === "rejected") {
                onRejected(this.error)
            }
        }
    }
异步实现
[x] 6、异步实现
至此，基本实现简单的同步代码，但是当 resolve 在 setTimeout 内执行，then 时 state 还是 pending 等待状态。我们就需要在 then 调用的时候，将成功和失败存到各自的数组，一旦 reject 或者 resolve，就调用它们。

类似于分布订阅，先将 then 内的两个函数存储，由于 promise 可以有多个 then，所以存在同一个数组内。当成功或失败的时候用 forEach 调用他们。

+           ```
        class Promise {
            constructor(executor) {
                this.status = "pending"; // 默认promise状态
                this.value;  // resolve成功时的值
                this.error;  // reject失败时的值
        
    + this.resolveQueue = []; // 成功存放的数组
    
    + this.rejectQueue = []; // 失败存放法数组
    
      let resolve = value => {
          if(this.status === "pending") {
              this.value = value;
              this.status = "resolved";
              // 一旦resolve执行，调用成功数组的函数
    
    + this.resolveQueue.forEach(fn => fn());
      }
      }
    
      let reject = value => {
          if(this.status === "pending") {
              this.error = value;
              this.status = "rejected";
          }
          // 一旦reject执行，调用失败数组的函数
    
    + this.rejectQueue.forEach(fn => fn());
      }
    
      executor(resolve, reject)
      }
    
      // 执行到then的时候
      then(onFullfilled, onRejected) {
          if(this.status === "resolved") {
              
                  onFullfilled(this.value);
           
          }
          if(this.status === "rejected") {
            
                  onRejected(this.error);
             
          }
          // 当状态state为pending时
    
    + if(this.status === "pending") {
          // onFulfilled传入到成功数组
    
    + this.resolveQueue.push(() => {
    
    + onFullfilled(this.value);
    
    + })
       // onRejected传入到失败数组
    
    + this.rejectQueue.push(() => {
    
    + onRejected(this.error);
    
    + })
    
    + }
      }
      }
    ```
    
    

# 浏览器缓存

浏览器缓存是用户层的一种缓存，用户层的缓存还有DNS缓存，包括代理层，web层，应用层，数据层，系统层，物理层都有相应的缓存机制，**每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟**

当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。

**（1）减少页面加载时间；（2）减少服务器负载；**

**浏览器是否使用缓存、缓存多久，是由服务器控制的**。准确来说，当浏览器请求一个网页（或者其他资源）时，**服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息**。下面看下，HTTP报文中与缓存相关的首部字段：

1. **通用首部字段**（就是请求报文和响应报文都能用上的字段）

   ![img](https://upload-images.jianshu.io/upload_images/2062729-bc884e2b5b6550a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/649/format/webp)

   

2. **请求首部字段**

   ![img](https://upload-images.jianshu.io/upload_images/2062729-85300cde629827d0.png?imageMogr2/auto-orient/strip|imageView2/2/w/649/format/webp)

   

3. **响应首部字段**

   ![img](https://upload-images.jianshu.io/upload_images/2062729-6069a96f6ef7166a.png?imageMogr2/auto-orient/strip|imageView2/2/w/648/format/webp)

   

4. **实体首部字段**

   ![img](https://upload-images.jianshu.io/upload_images/2062729-b6d047fdc1f7839a.png?imageMogr2/auto-orient/strip|imageView2/2/w/648/format/webp)

   根据上面四种类型的首部字段不同使用策略，**浏览器中缓存可分为强缓存和协商缓存**：

   > 1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，**强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器**。比如：某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；
   >
   > 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，**通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存**，如果协商缓存命中，服务器会将这个请求返回，**但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源**，于是浏览器就又会从自己的缓存中去加载这个资源；
   >
   > 3）强缓存与协商缓存的共同点是：**如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据**；区别是：**强缓存不发请求到服务器，协商缓存会发请求到服务器**。
   >
   > 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

   

   

   ## 3.1 强缓存：Expires&Cache-Control

   当浏览器对某个资源的请求命中了强缓存时，**返回的HTTP状态为200**，在chrome的开发者工具的network里面 **size会显示为from cache**，比如：京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的：

   ![img](https:////upload-images.jianshu.io/upload_images/2062729-e8891a58fb35efca.png?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp)

   命中强缓存

   > **强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期**。

   **Expires是HTTP 1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示**，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，包含了Expires头标签的文件，就说明浏览器对于该文件缓存具有非常大的控制权。

   例如，一个文件的Expires值是2020年的1月1日，那么就代表，在2020年1月1日之前，浏览器都可以直接使用该文件的本地缓存文件，而不必去服务器再次请求该文件，哪怕服务器文件发生了变化。

   所以，**Expires是优化中最理想的情况，因为它根本不会产生请求**，所以后端也就无需考虑查询快慢。它的缓存原理，如下：

   1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Expires的header，如：

      ![img](https:////upload-images.jianshu.io/upload_images/2062729-adb82222396c4c79.png?imageMogr2/auto-orient/strip|imageView2/2/w/378/format/webp)

      response的header加上Expires

   2. 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；

   3. 浏览器再请求这个资源时，**先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较**，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；

   4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新；

   Expires是较老的强缓存管理header，**由于它是服务器返回的一个绝对时间**，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，**比如：随意修改下客户端时间，就能影响缓存命中的结果**。所以在HTTP 1.1的时候，提出了一个新的header，**就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示**，如：Cache-Control:max-age=315360000，它的缓存原理是：

   1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header，如：

      ![img](https:////upload-images.jianshu.io/upload_images/2062729-229d5a79f1aef88d.png?imageMogr2/auto-orient/strip|imageView2/2/w/551/format/webp)

      response的header加上Cache-Control

   2. 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；

   3. 浏览器再请求这个资源时，**先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期**，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；

   4. 如果缓存没有命中，浏览器直接从服务器加载资源时，**Cache-Control Header在重新加载的时候会被更新**；

   **Cache-Control描述的是一个相对时间**，在进行缓存命中的时候，**都是利用客户端时间进行判断**，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。

   这两个header可以只启用一个，也可以同时启用，**当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires**：

   ![img](https:////upload-images.jianshu.io/upload_images/2062729-36cff7765f849c39.png?imageMogr2/auto-orient/strip|imageView2/2/w/491/format/webp)

   Cache-Control优先级高于Expires
   
   此外，还可以为 Cache-Control 指定 `public` 或 `private` 标记。**如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源**。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。**对于 public，则允许所有服务器缓存该资源**。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），**Cache-Control 默认设为 public 是合理的**。
   
   

## 3.2 协商缓存：Last-Modified&Etag

当浏览器对某个资源的请求没有命中强缓存，**就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串**

> **协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的**。

**【Last-Modified，If-Modified-Since】的控制缓存的原理，如下**：

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，**在response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间**：

   ![img](https:////upload-images.jianshu.io/upload_images/2062729-63aac2be7c2da710.png?imageMogr2/auto-orient/strip|imageView2/2/w/418/format/webp)

   response的header加上Last-Modified

2. 浏览器再次跟服务器请求这个资源时，**在request的header上加上If-Modified-Since的header**，这个header的值就是上一次请求时返回的Last-Modified的值：

   ![img](https:////upload-images.jianshu.io/upload_images/2062729-91e5d033e94a32a2.png?imageMogr2/auto-orient/strip|imageView2/2/w/844/format/webp)

   request的header上加上If-Modified-Since

3. 服务器再次收到资源请求时，**根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化**，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。**当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header**，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：

   ![img](https:////upload-images.jianshu.io/upload_images/2062729-fbf1d88661000044.png?imageMogr2/auto-orient/strip|imageView2/2/w/380/format/webp)

   服务器响应304 Not Modified

4. 浏览器收到304的响应后，就会从缓存中加载资源。

5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，**Last-Modified Header在重新加载的时候会被更新**，下次请求时，**If-Modified-Since会启用上次返回的Last-Modified值**。

【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，**在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况**，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。**所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】**。它们的缓存管理的方式是：

1. 浏览器第一次跟服务器请求一个资源，**服务器在返回这个资源的同时，在response的header加上ETag的header**，这个header是服务器根据当前请求的资源生成的一个唯一标识，**这个唯一标识是一个字符串，只要资源有变化这个串就不同**，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：

   ![img](https:////upload-images.jianshu.io/upload_images/2062729-e9fe1ffe27888e34.png?imageMogr2/auto-orient/strip|imageView2/2/w/398/format/webp)

   在response的header加上ETag

2. 浏览器再次跟服务器请求这个资源时，**在request的header上加上If-None-Match的header**，这个header的值就是上一次请求时返回的ETag的值：

   ![img](https:////upload-images.jianshu.io/upload_images/2062729-e8fe8c5c4ca2cd0b.png?imageMogr2/auto-orient/strip|imageView2/2/w/822/format/webp)

   在request的header上加上If-None-Match

3. 服务器再次收到资源请求时，**根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag**，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，**由于ETag重新生成过，response header中还会把这个ETag返回**，即使这个ETag跟之前的没有变化：

   ![img](https:////upload-images.jianshu.io/upload_images/2062729-2d10cc22a66812ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/374/format/webp)

   由于ETag重新生成过，response header中还会把这个ETag返回

4. 浏览器收到304的响应后，就会从缓存中加载资源。

Etag和Last-Modified非常相似，都是用来判断一个参数，从而决定是否启用缓存。**但是ETag相对于Last-Modified也有其优势，可以更加准确的判断文件内容是否被修改**，从而在实际操作中实用程度也更高。

协商缓存跟强缓存不一样，强缓存不发请求到服务器，**所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器**，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:

![img](https:////upload-images.jianshu.io/upload_images/2062729-28f09f7605d95874.png?imageMogr2/auto-orient/strip|imageView2/2/w/468/format/webp)

同时开启Etag和Last-Modified

如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。

【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：

> **分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败**；
>
> **分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）**；

比如，京东页面的资源请求，返回的repsonse header就只有Last-Modified，没有ETag：

![img](https:////upload-images.jianshu.io/upload_images/2062729-55d31df94f4eae8a.png?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp)

repsonse header只开启Last-Modified

协商缓存需要配合强缓存使用，上面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，**因为如果不启用强缓存的话，协商缓存根本没有意义**。

4 缓存判断流程

如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。其浏览器判断缓存的详细流程图，如下：

![img](https:////upload-images.jianshu.io/upload_images/2062729-86c3eb001edb80d5.png?imageMogr2/auto-orient/strip|imageView2/2/w/967/format/webp)

# Vue-生命周期详解

![Vue 实例生命周期](https://cn.vuejs.org/images/lifecycle.png)

![image-20210328160459377](D:\Typora\img\image-20210328160459377.png)

##### **1. 在beforeCreate和created钩子函数之间的生命周期**

在这个生命周期之间，进行**初始化事件，进行数据的观测**，可以看到在**created**的时候数据已经和**data属性进行绑定**（放在data中的属性当值发生改变的同时，视图也会改变）。
注意看下：此时还是没有el选项

##### **2. created钩子函数和beforeMount间的生命周期**

![clipboard.png](https://segmentfault.com/img/bVVUb9?w=571&h=509)

在这一阶段发生的事情还是比较多的。

首先会判断对象是否有**el选项**。**如果有的话就继续向下编译，如果没有**el选项**，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。**此时注释掉代码中:

```
el: '#app',
```

然后运行可以看到到created的时候就停止了：

![clipboard.png](https://segmentfault.com/img/bVVUB3?w=764&h=285)

如果我们在后面继续调用vm.$mount(el),可以发现代码继续向下执行了

```
vm.$mount(el) //这个el参数就是挂在的dom接点
```

![clipboard.png](https://segmentfault.com/img/bVVUCG?w=691&h=441)

然后，我们往下看，**template**参数选项的有无对生命周期的影响。
（1）.如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。
（2）.如果没有template选项，则将外部HTML作为模板编译。
（3）.可以看到template中的模板优先级要高于outer HTML的优先级。
修改代码如下, 在HTML结构中增加了一串html，在vue对象中增加了**template选项**：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>vue生命周期学习</title>
  <script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"></script>
</head>
<body>
  <div id="app">
    <!--html中修改的-->
    <h1>{{message + '这是在outer HTML中的'}}</h1>
  </div>
</body>
<script>
  var vm = new Vue({
    el: '#app',
    template: "<h1>{{message +'这是在template中的'}}</h1>", //在vue配置项中修改的
    data: {
      message: 'Vue的生命周期'
    }
</script>
</html>
```

执行后的结果可以看到在页面中显示的是：

![clipboard.png](https://segmentfault.com/img/bVVUJT?w=910&h=118)

那么将vue对象中template的选项注释掉后打印如下信息：

![clipboard.png](https://segmentfault.com/img/bVVUJ3?w=717&h=97)

这下就可以想想什么**el的判断**要在template之前了~是因为vue需要通过el找到对应的outer template。

在vue对象中还有一个**render函数**，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX.

```
new Vue({
    el: '#app',
    render: function(createElement) {
        return createElement('h1', 'this is createElement')
    }
})
```

可以看到页面中渲染的是：

![clipboard.png](https://segmentfault.com/img/bVVUSo?w=477&h=76)

所以综合排名优先级：
render函数选项 > template选项 > outer HTML.

##### **3. beforeMount和mounted 钩子函数间的生命周期**

![clipboard.png](https://segmentfault.com/img/bVVUTK?w=451&h=198)

可以看到此时是给vue实例对象添加**$el成员**，并且替换掉挂在的DOM元素。因为在之前console中打印的结果可以看到**beforeMount**之前el上还是undefined。

![image-20210419154426198](D:\Typora\img\image-20210419154426198.png)

##### **4. mounted**

注意看下面截图：

![clipboard.png](https://segmentfault.com/img/bVVUYC?w=424&h=274)

在mounted之前h1中还是通过**{{message}}**进行占位的，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在mounted之后可以看到h1中的内容发生了变化。

##### **5. beforeUpdate钩子函数和updated钩子函数间的生命周期**

![clipboard.png](https://segmentfault.com/img/bVVU0E?w=558&h=295)

当vue发现data中的数据发生了改变，会**触发对应组件的重新渲染**，先后调用**beforeUpdate**和**updated**钩子函数。我们在console中输入：

```
vm.message = '触发组件更新'
```

发现触发了组件的更新：

![clipboard.png](https://segmentfault.com/img/bVVU55?w=500&h=356)

##### **6.beforeDestroy和destroyed钩子函数间的生命周期**

![clipboard.png](https://segmentfault.com/img/bVVU6C?w=383&h=368)

**beforeDestroy**钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。
**destroyed**钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

# 对闭包的理解

**如果一个函数用到了它作用域外面的变量，那么这个变量和这个函数之间的环境就叫闭包。**

由于函数变量的作用域是一个作用链域，而且函数中声明的变量在函数运行后就会被回收，但子函数‘捕获’到一个父函数中的变量或对象就会将其存入全局环境中不会被回收(**好处**)从而实现了对一个变量的私有化，或者对一个变量的全局保存。减少因此产生的命名冲突等，避免污染全局环境.

**1.模仿块级作用域**

**2.储存变量**

**3.封装私有变量**

**4.函数柯里化！！**

# 闭包滥用可能会引起内存泄漏

https://www.cnblogs.com/cwxwdm/p/10845376.html

## 什么是内存泄漏

内存泄露是指当一块内存不再被应用程序使用的时候，由于某种原因，这块内存没有返还给操作系统或者内存池的现象。内存泄漏可能会导致应用程序卡顿或者崩溃。

## 常见的内存泄漏

![img](https://img2018.cnblogs.com/blog/1632708/201905/1632708-20190510164454531-528240583.png)

以上代码创建了一个作为 element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用，匿名函数中保存了一个对 element 对象的引用，因此无法减少 element 的引用数。只要匿名函数在，element 的引用数至少是 1，因此它所占用的内存就永远无法回收。

解决办法：

![img](https://img2018.cnblogs.com/blog/1632708/201905/1632708-20190510164516302-736987004.png)

### 意外的全局变量

### 被遗忘的定时器

定时器设为null并不会消失 要用clearInterval

### 闭包滥用	

# 函数柯里化

首先记住一句话 函数柯里化，其实就是把多次调用的变量保存在闭包中，每次调用都查看一下变量数和原函数的形参数量是否相等。不相等就继续递归。直到相等为止就处理了。

函数柯里化实现

```
function curry(fn,args){
    var length = fn.length // 获得fn应有的形参数量

    var arg = args || [] // 如果初始变量有传进去就用初始变量作为初始值，不然就是空数组，用于收集后续调用的变量

    return function(){
        var _arg = arg.slice(0) // 外面变量的副本
            //  循环的是return 的这个funciton的传入实参的长度
        for(var i =0 ;i<arguments.length;i++){
            // 把变量全部传入这个存储总变量的副本中

            _arg.push(arguments[i])
        }
        //如果小于说明还没达到理想的参数数量，继续柯里化等待下一轮参数
        if(_arg.length<length){
            return curry.call(this,fn,_arg) // 这个设置this是因为如果以后有对象进行调用的能指向对象的内部，不然就指向window了
        }else{
            return fn.apply(this._arg) // 执行原函数
        }
    }
}
```

```jsx
// 实现一个add方法，使计算结果能够满足如下预期：
add(1)(2)(3) = 6;
add(1, 2, 3)(4) = 10;
add(1)(2)(3)(4)(5) = 15;

function add() {
    // 第一次执行时，定义一个数组专门用来存储所有的参数
    var _args = Array.prototype.slice.call(arguments);

    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
    var _adder = function() {
        _args.push(...arguments);
        return _adder;
    };

    // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
    _adder.toString = function () {
        return _args.reduce(function (a, b) {
            return a + b;
        });
    }
    return _adder;
}

add(1)(2)(3)                // 6
add(1, 2, 3)(4)             // 10
add(1)(2)(3)(4)(5)          // 15
add(2, 6)(1)                // 9
```

# session cookie   session storage  localstorage

https://blog.csdn.net/jiangnanqbey/article/details/81709322

# XSS和CSRF攻击及防御

XSS跨站脚本攻击（Cross Site Scripting)

- **Reflected XSS**（基于反射的 XSS攻击）：是指xss代码在请求的url中，而后提交到服务器，服务器解析后，XSS代码随着响应内容一起传给客户端进行解析执行。（直接反射显示在页面）

- **Stored XSS**（基于存储的 XSS攻击）：Stored XSS和 Reflected XSS的差别就在于，具有攻击性的脚本被保存到了服务器端（数据库，内存，文件系统）并且可以被普通用户完整的从服务的取得并执行，从而获得了在网络上传播的能力。

- **DOM-based or local XSS**（基于DOM或本地的 XSS 攻击）：DOM型 XSS其实是一种特殊类型的反射型 XSS，它是基于 DOM文档对象模型的一种漏洞。可以通过 DOM来动态修改页面内容，从客户端获取 DOM中的数据并在本地执行。基于这个特性，就可以利用 JS脚本来实现 XSS漏洞的利用。

- ##### 1.1 XSS 情景再现

  （1）在网页 input 或者 textarea 中输入 <script>alert('xss')</script>或者其他脚本

  （2）直接使用 URL 参数攻击
   `https://www.baidu.com?jarttoTest=<script>alert(document.cookie)</script>`

  ##### 1.2 XSS防御

  ###### （1）输入过滤，避免 XSS 的方法之一主要是将用户输入的内容进行过滤。对所有用户提交内容进行可靠的输入验证，包括对 URL、查询关键字、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。(客户端和服务器都要)

  ###### （2）输出转义

  内容，代码，url转义

  ###### （3）使用 HttpOnly Cookie

  将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。

  

  ##### 2.[跨站请求伪造（CSRF）](https://juejin.im/post/59e6b21bf265da43247f861d) （Cross-site request forgery）

  CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但它们的攻击类型是不同维度上的分 类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。

  ##### 2.1 CSRF 情景

  示例一：银行网站 A，它以 GET 请求来完成银行转账的操作，如：

  

  ```cpp
  http://www.mybank.com/Transfer.php?toBankId=11&money=1000
  ```

  危险网站 B，它里面有一段 HTML 的代码如下:

  

  ```xml
  <img src=http://www.mybank.com/Transfer.php?toBankId=11&money=1000>
  ```

  首先，你登录了银行网站 A ，然后访问危险网站 B ，噢，这时你会发现你的银行账户少了 1000 块…

  ##### 2.2CSRF 漏洞如何防御？

  （1）验证 HTTP Referer 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer记录了该 HTTP 请求的来源地址。

  > 优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。
  >  缺点：
  >  Referer 的值是由浏览器提供的，不可全信，低版本浏览器下 Referer 存在伪造风险。
  >  用户自己可以设置浏览器使其在发送请求时不再提供 Referer 时，网站将拒绝合法用户的访问。

  （2）在请求地址中添加 token 并验证
   CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。
   补充一点：通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。

  > 优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。
  >  缺点：对所有请求都添加 token 比较困难。难以保证 token 本身的安全，依然会被利用获取到 token。

  （3）在 HTTP 头中自定义属性并验证
   这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。

  > 优点：统一管理 token 输入输出，可以保证 token 的安全性。
  >  缺点：有局限性，无法在非异步的请求上实施。

# Vue实现数据双向绑定的原理是什么

**1、vue的数据双向绑定是通过数据劫持和发布-订阅者功能来实现的**	

**2、vue是通过Object.defineProperty()来实现数据劫持的。**

实现mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据。 

关键点在于 data 如何更新view

因为 view 更新 data 其实可以通过事件监听即可，比如 input 标签监听 'input' 事件就可以实现了。

而数据更新视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的事都好处理。如何知道数据变了，就是通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了。



当 data 有变化的时候，通过ES5 中的 Object.defineProperty() 方法中的 set 方法劫持属性值的设置操作和 get 方法劫持属性值的获取操作，实现数据变化视图 view 跟着变化；

而视图 view 变化数据跟着变化则是通过底层的 input 事件来进行 data 的响应更改

Object.defineProperty(参数1，参数2，参数3)   返回值为该对象obj

参数1为该对象（obj），参数2为要定义或修改的对象的属性名，参数3为属性描述符，属性描述符是一个对象，主要有两种形式：数据描述符和存取描述符。这两种对象只能选择一种使用，不能混合使用。而get和set属于存取描述符对象的属性。

这个方法会直接在一个对象上定义一个新属性或者修改对象上的现有属性，并返回该对象

# HTTPS

首先是使用了非对称加密协商获取了加密方式

非对称文加密就是说A的公钥加密的只有A的私钥可以解密，任何有A的公钥的人都可以确认对方发送的内容是被私钥加密过的

![image-20210407113536686](D:\Typora\img\image-20210407113536686.png)

![image-20210407113703272](D:\Typora\img\image-20210407113703272.png)

![image-20210407114305780](D:\Typora\img\image-20210407114305780.png)

勘误：不是一边使用一个随机数 而是双方都同时使用两个随机数

# 前端性能优化

https://segmentfault.com/a/1190000022205291